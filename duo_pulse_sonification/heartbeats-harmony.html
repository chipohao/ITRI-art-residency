<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>Heartbeats in Harmony</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.4/p5.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: #000000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: 'Courier New', monospace;
      color: #999999;
    }

    h1 {
      font-size: 10px;
      letter-spacing: 5px;
      text-transform: uppercase;
      margin-bottom: 16px;
      opacity: 0.4;
    }

    #controls {
      display: flex;
      gap: 36px;
      padding-bottom: 14px;
      align-items: flex-end;
    }

    .ctrl {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }

    .lbl { font-size: 8px; letter-spacing: 3px; opacity: 0.4; text-transform: uppercase; }
    .val { font-size: 34px; line-height: 1.1; }
    .sub { font-size: 8px; letter-spacing: 1px; opacity: 0.28; min-height: 12px; }

    .divider {
      width: 1px;
      height: 50px;
      background: #222222;
      margin-bottom: 8px;
    }

    input[type=range] {
      -webkit-appearance: none;
      appearance: none;
      width: 110px;
      height: 1px;
      background: #252525;
      cursor: pointer;
      margin-top: 7px;
    }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ffffff;
      cursor: pointer;
    }

    #wrap {
      position: relative;
      width: 720px;
      height: 500px;
    }

    #wrap canvas {
      position: absolute;
      top: 0; left: 0;
      display: block;
    }

    #scanlines {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: repeating-linear-gradient(
        to bottom,
        transparent 0px, transparent 2px,
        rgba(0,0,0,0.1) 2px, rgba(0,0,0,0.1) 3px
      );
      z-index: 2;
    }

    #vignette {
      position: absolute;
      inset: 0;
      pointer-events: none;
      background: radial-gradient(
        ellipse at center,
        transparent 38%,
        rgba(0,0,0,0.72) 100%
      );
      z-index: 3;
    }

    #footer {
      display: flex;
      align-items: center;
      gap: 28px;
      margin-top: 14px;
    }

    button {
      background: none;
      border: 1px solid #2a2a2a;
      color: #888888;
      font-family: 'Courier New', monospace;
      font-size: 9px;
      letter-spacing: 4px;
      text-transform: uppercase;
      padding: 5px 14px;
      cursor: pointer;
      opacity: 0.5;
      transition: opacity 0.15s;
    }
    button:hover { opacity: 0.9; }
    #ratio { font-size: 9px; letter-spacing: 2px; opacity: 0.22; }

    #serial-status {
      font-size: 8px;
      letter-spacing: 2px;
      opacity: 0.35;
    }
    #serial-status.connected { color: #88cc44; opacity: 0.7; }
    #serial-status.calibrating { color: #aaaaaa; opacity: 0.7; }

    #pen-coords {
      font-size: 8px;
      letter-spacing: 2px;
      opacity: 0.45;
      font-variant-numeric: tabular-nums;
      min-width: 140px;
      text-align: center;
    }

    select {
      -webkit-appearance: none;
      appearance: none;
      background: none;
      border: 1px solid #2a2a2a;
      color: #888888;
      font-family: 'Courier New', monospace;
      font-size: 9px;
      letter-spacing: 2px;
      padding: 5px 10px;
      cursor: pointer;
      opacity: 0.5;
      transition: opacity 0.15s;
      max-width: 180px;
    }
    select:hover, select:focus { opacity: 0.9; outline: none; }
    select option { background: #000000; color: #888888; }
  </style>
</head>
<body>

  <h1>Heartbeats in Harmony</h1>

  <div id="controls">
    <div class="ctrl">
      <div class="lbl">Heart A</div>
      <div class="val" id="val-a">72</div>
      <div class="sub" id="hz-a">1.20 Hz</div>
      <input type="range" id="sl-a" min="40" max="160" value="72">
    </div>

    <div class="divider"></div>

    <div class="ctrl">
      <div class="lbl">Heart B</div>
      <div class="val" id="val-b">80</div>
      <div class="sub" id="hz-b">1.33 Hz</div>
      <input type="range" id="sl-b" min="40" max="160" value="80">
    </div>

    <div class="divider"></div>

    <div class="ctrl">
      <div class="lbl">Phase</div>
      <div class="val" id="val-phase">45°</div>
      <div class="sub">&nbsp;</div>
      <input type="range" id="sl-phase" min="0" max="360" value="45" step="1">
    </div>

    <div class="divider"></div>

    <div class="ctrl">
      <div class="lbl">Trail</div>
      <div class="val" id="val-fade">∞</div>
      <div class="sub" id="sub-fade">&nbsp;</div>
      <input type="range" id="sl-fade" min="0" max="100" value="0" step="1">
    </div>
  </div>

  <div id="wrap">
    <div id="scanlines"></div>
    <div id="vignette"></div>
  </div>

  <div id="footer">
    <div id="ratio">ratio —</div>
    <button id="btn-scan">Scan Port</button>
    <select id="sel-port"><option value="">— no port —</option></select>
    <div id="serial-status">disconnected</div>
    <div id="pen-coords">x —&nbsp;&nbsp;&nbsp; y —</div>
    <button id="btn-clear">Clear</button>
  </div>

  <script>
    const state = {
      bpmA:    72,
      bpmB:    80,
      phase:   Math.PI / 4,
      fade:    0,
      fingerA: false,
      fingerB: false
    };
    let needsClear = false;

    function gcd(a, b) { return b === 0 ? a : gcd(b, a % b); }
    function updateRatio() {
      const g = gcd(state.bpmA, state.bpmB);
      document.getElementById('ratio').textContent =
        `ratio  ${state.bpmA/g} : ${state.bpmB/g}`;
    }
    updateRatio();

    document.getElementById('sl-a').addEventListener('input', function() {
      state.bpmA = +this.value;
      document.getElementById('val-a').textContent = this.value;
      document.getElementById('hz-a').textContent = (state.bpmA/60).toFixed(2) + ' Hz';
      updateRatio();
    });
    document.getElementById('sl-b').addEventListener('input', function() {
      state.bpmB = +this.value;
      document.getElementById('val-b').textContent = this.value;
      document.getElementById('hz-b').textContent = (state.bpmB/60).toFixed(2) + ' Hz';
      updateRatio();
    });
    document.getElementById('sl-phase').addEventListener('input', function() {
      state.phase = +this.value * Math.PI / 180;
      document.getElementById('val-phase').textContent = this.value + '°';
    });
    document.getElementById('sl-fade').addEventListener('input', function() {
      state.fade = +this.value;
      if (state.fade === 0) {
        document.getElementById('val-fade').textContent = '∞';
        document.getElementById('sub-fade').textContent = '\u00a0';
      } else {
        const hl = Math.pow(20, 1 - state.fade / 100) * 0.3;
        document.getElementById('val-fade').textContent = hl < 1 ? hl.toFixed(1) : Math.round(hl);
        document.getElementById('sub-fade').textContent = 'sec';
      }
    });
    document.getElementById('btn-clear').addEventListener('click', () => {
      needsClear = true;
    });

    // ── Web Serial API ────────────────────────────────────────────────────
    let serialPort   = null;
    let serialReader = null;
    let serialWriter = null;
    let availablePorts = [];
    const statusEl  = document.getElementById('serial-status');
    const selPort   = document.getElementById('sel-port');
    const coordsEl  = document.getElementById('pen-coords');
    const te        = new TextEncoder();

    function penWrite(text) {
      if (!serialWriter) return;
      serialWriter.write(te.encode(text)).catch(() => {});
    }

    function setSerialStatus(cls, text) {
      statusEl.className   = cls;
      statusEl.textContent = text;
    }

    function portLabel(port, idx) {
      const info = port.getInfo();
      if (info.usbVendorId) {
        const vid = info.usbVendorId.toString(16).padStart(4, '0');
        const pid = info.usbProductId.toString(16).padStart(4, '0');
        return `port ${idx + 1}  [${vid}:${pid}]`;
      }
      return `port ${idx + 1}`;
    }

    function renderPortList() {
      while (selPort.options.length > 1) selPort.remove(1);
      availablePorts.forEach((p, i) => selPort.add(new Option(portLabel(p, i), i)));
    }

    function applyBpmA(bpm) {
      bpm = Math.max(40, Math.min(160, bpm));
      state.bpmA = bpm;
      document.getElementById('sl-a').value        = bpm;
      document.getElementById('val-a').textContent = bpm;
      document.getElementById('hz-a').textContent  = (bpm / 60).toFixed(2) + ' Hz';
      updateRatio();
    }

    function applyBpmB(bpm) {
      bpm = Math.max(40, Math.min(160, bpm));
      state.bpmB = bpm;
      document.getElementById('sl-b').value        = bpm;
      document.getElementById('val-b').textContent = bpm;
      document.getElementById('hz-b').textContent  = (bpm / 60).toFixed(2) + ' Hz';
      updateRatio();
    }

    async function readSerial() {
      setSerialStatus('calibrating', 'calibrating...');
      let buf = '';
      const td = new TextDecoder();
      serialReader = serialPort.readable.getReader();

      try {
        while (true) {
          const { value, done } = await serialReader.read();
          if (done) break;
          buf += td.decode(value, { stream: true });
          let nl;
          while ((nl = buf.indexOf('\n')) !== -1) {
            const line = buf.slice(0, nl).trim();
            buf = buf.slice(nl + 1);
            const m = line.match(/^\/pulse\/(userA|userB)\/(bpm|finger|beat)\s+(\d+)/);
            if (!m) continue;
            const [, user, type, valStr] = m;
            const val = parseInt(valStr, 10);
            if (type === 'bpm' && val > 30) {
              if (user === 'userA') applyBpmA(val);
              else                  applyBpmB(val);
              setSerialStatus('connected', 'connected');
            } else if (type === 'finger') {
              if (user === 'userA') state.fingerA = val === 1;
              else                  state.fingerB = val === 1;
            } else if (type === 'beat' && val === 1) {
              // Trigger beat flash directly from real hardware beat
              if (user === 'userA') state.triggerBeatA = true;
              else                  state.triggerBeatB = true;
            }
          }
        }
      } catch (e) {
        // cancelled or port closed
      } finally {
        try { serialWriter?.releaseLock(); } catch {}
        serialWriter = null;
        try { serialReader.releaseLock(); } catch {}
        serialReader  = null;
        state.fingerA = false;
        state.fingerB = false;
        setSerialStatus('', 'disconnected');
        selPort.value = '';
      }
    }

    async function disconnectCurrent() {
      if (!serialPort) return;
      const p = serialPort;
      serialPort = null;
      try { await serialReader?.cancel(); } catch {}
      await new Promise(r => setTimeout(r, 80));
      try { await p.close(); } catch {}
    }

    async function connectToPort(port) {
      await disconnectCurrent();
      serialPort = port;
      try {
        await serialPort.open({ baudRate: 115200 });
        try { serialWriter = serialPort.writable.getWriter(); } catch(e) {}
        readSerial();
      } catch (e) {
        serialPort = null;
        setSerialStatus('', 'open failed');
        selPort.value = '';
      }
    }

    selPort.addEventListener('change', function () {
      if (this.value === '') { disconnectCurrent(); return; }
      connectToPort(availablePorts[+this.value]);
    });

    document.getElementById('btn-scan').addEventListener('click', async () => {
      if (!navigator.serial) {
        alert('Web Serial API not supported.\nPlease use Chrome or Edge (desktop).');
        return;
      }
      try {
        const newPort = await navigator.serial.requestPort();
        if (!availablePorts.includes(newPort)) availablePorts.push(newPort);
        renderPortList();
        selPort.value = availablePorts.indexOf(newPort);
        connectToPort(newPort);
      } catch (e) { /* user cancelled */ }
    });

    if (navigator.serial) {
      navigator.serial.getPorts().then(ports => {
        availablePorts = ports;
        renderPortList();
      });
      navigator.serial.addEventListener('disconnect', () => {
        navigator.serial.getPorts().then(ports => {
          availablePorts = ports;
          renderPortList();
        });
      });
    }

    // Also expose beat triggers on state for serial-driven flash
    state.triggerBeatA = false;
    state.triggerBeatB = false;

    new p5(function(p) {
      const W = 720, H = 500;
      const LX = W / 2, LY = 200, LR = 158;
      const CA = { x: 92,  y: 400, r: 52 };
      const CB = { x: 628, y: 400, r: 52 };

      let pg1, pg2;
      let t = 0;
      let angleA = -Math.PI / 2;
      let angleB = -Math.PI / 2;
      let prevAngleA = angleA;
      let prevAngleB = angleB;
      let pulseA = { r: 0, a: 0 };
      let pulseB = { r: 0, a: 0 };
      let flashA = 0;   // beat flash brightness, 0–255
      let flashB = 0;

      p.setup = function() {
        const cv = p.createCanvas(W, H);
        cv.parent('wrap');
        cv.elt.style.zIndex = '1';

        pg1 = p.createGraphics(W, H);
        pg2 = p.createGraphics(W, H);
        pg1.background(0);
        pg2.background(0);
        p.noSmooth();
      };

      p.draw = function() {
        if (needsClear) {
          pg1.background(0);
          pg2.background(0);
          t = 0;
          angleA = prevAngleA = -Math.PI / 2;
          angleB = prevAngleB = -Math.PI / 2;
          pulseA = { r: 0, a: 0 };
          pulseB = { r: 0, a: 0 };
          flashA = 0; flashB = 0;
          needsClear = false;
        }

        const dt    = Math.min(p.deltaTime / 1000, 0.05);
        const freqA = state.bpmA / 60;
        const freqB = state.bpmB / 60;

        // ── Step 1: Fade ──────────────────────────────────────────────
        pg2.background(0);

        if (state.fade > 0) {
          const halfLife  = Math.pow(20, 1 - state.fade / 100) * 0.3;
          const keepRatio = Math.pow(0.5, dt / halfLife);
          pg2.drawingContext.globalAlpha = keepRatio;
          pg2.drawingContext.drawImage(pg1.elt, 0, 0, W, H);  // W,H fix retina (pixelDensity=2)
          pg2.drawingContext.globalAlpha = 1.0;
        } else {
          pg2.drawingContext.drawImage(pg1.elt, 0, 0, W, H);
        }

        // ── Step 2: Sand particles → pg2 (white) ──────────────────────
        const SUB = 10;
        pg2.drawingContext.shadowBlur  = 5;
        pg2.drawingContext.shadowColor = 'rgba(255, 255, 255, 0.22)';

        for (let s = 0; s < SUB; s++) {
          const ts = t + s * (dt / SUB);
          const x  = LX + LR * Math.sin(freqA * ts * p.TWO_PI);
          const y  = LY + LR * Math.sin(freqB * ts * p.TWO_PI + state.phase);

          for (let i = 0; i < 12; i++) {
            const ox = p.randomGaussian(0, 1.5);
            const oy = p.randomGaussian(0, 1.5);
            const d2 = ox * ox + oy * oy;
            const al = p.map(d2, 0, 10, 150, 10, true);
            pg2.noStroke();
            pg2.fill(255, 255, 255, al);
            pg2.circle(x + ox, y + oy, p.random(0.5, 1.8));
          }
        }

        pg2.drawingContext.shadowBlur = 0;

        // ── Step 3: Swap buffers ──────────────────────────────────────
        [pg1, pg2] = [pg2, pg1];

        const penX = LX + LR * Math.sin(freqA * t * p.TWO_PI);
        const penY = LY + LR * Math.sin(freqB * t * p.TWO_PI + state.phase);
        t += dt;

        // ── Step 4: Beat detect (simulated from angle, or real from serial) ──
        prevAngleA = angleA;
        prevAngleB = angleB;
        angleA += freqA * dt * p.TWO_PI;
        angleB += freqB * dt * p.TWO_PI;

        const beatA = (angleA % p.TWO_PI) < (prevAngleA % p.TWO_PI) || state.triggerBeatA;
        const beatB = (angleB % p.TWO_PI) < (prevAngleB % p.TWO_PI) || state.triggerBeatB;
        state.triggerBeatA = false;
        state.triggerBeatB = false;

        if (beatA) { pulseA.r = CA.r * 1.1; pulseA.a = 200; flashA = 255; }
        if (beatB) { pulseB.r = CB.r * 1.1; pulseB.a = 200; flashB = 255; }

        // Expanding ring decay
        pulseA.r += dt * 55;  pulseA.a = Math.max(0, pulseA.a - dt * 280);
        pulseB.r += dt * 55;  pulseB.a = Math.max(0, pulseB.a - dt * 280);

        // Flash decay (~0.45s)
        flashA = Math.max(0, flashA - dt * 560);
        flashB = Math.max(0, flashB - dt * 560);

        const dotAX = CA.x + CA.r * Math.cos(angleA);
        const dotAY = CA.y + CA.r * Math.sin(angleA);
        const dotBX = CB.x + CB.r * Math.cos(angleB);
        const dotBY = CB.y + CB.r * Math.sin(angleB);

        // ── Step 5: Render ────────────────────────────────────────────
        p.image(pg1, 0, 0);

        // Connection lines (dashed)
        p.drawingContext.setLineDash([3, 6]);
        p.stroke(255, 255, 255, 40);
        p.strokeWeight(1);
        p.noFill();
        p.line(dotAX, dotAY, penX, penY);
        p.line(dotBX, dotBY, penX, penY);
        p.drawingContext.setLineDash([]);

        // ── Circle A ─────────────────────────
        // Beat flash: filled white circle fades quickly
        if (flashA > 0) {
          p.noStroke();
          p.fill(255, 255, 255, flashA * 0.65);
          p.circle(CA.x, CA.y, CA.r * 2);
        }

        p.noFill();
        p.stroke(255, 255, 255, 50);
        p.strokeWeight(1);
        p.circle(CA.x, CA.y, CA.r * 2);

        if (pulseA.a > 0) {
          p.noFill();
          p.stroke(255, 255, 255, pulseA.a);
          p.strokeWeight(1);
          p.circle(CA.x, CA.y, pulseA.r * 2);
        }

        p.stroke(255, 255, 255, 35);
        p.strokeWeight(0.8);
        p.line(CA.x, CA.y, dotAX, dotAY);

        p.noStroke(); p.fill(255, 255, 255, 70);
        p.circle(CA.x, CA.y, 4);

        p.noStroke(); p.fill(255, 255, 255, 210);
        p.circle(dotAX, dotAY, 8);

        p.fill(255, 255, 255, 65);
        p.noStroke();
        p.textFont('Courier New');
        p.textSize(8);
        p.textAlign(p.CENTER);
        p.text('HEART  A', CA.x, CA.y + CA.r + 15);
        p.text(state.bpmA + ' BPM', CA.x, CA.y + CA.r + 26);
        // Finger indicator: dim = no finger, bright = finger on
        p.noStroke();
        p.fill(255, 255, 255, state.fingerA ? 220 : 30);
        p.circle(CA.x, CA.y + CA.r + 38, 4);

        // ── Circle B ─────────────────────────
        if (flashB > 0) {
          p.noStroke();
          p.fill(255, 255, 255, flashB * 0.65);
          p.circle(CB.x, CB.y, CB.r * 2);
        }

        p.noFill();
        p.stroke(255, 255, 255, 50);
        p.strokeWeight(1);
        p.circle(CB.x, CB.y, CB.r * 2);

        if (pulseB.a > 0) {
          p.noFill();
          p.stroke(255, 255, 255, pulseB.a);
          p.strokeWeight(1);
          p.circle(CB.x, CB.y, pulseB.r * 2);
        }

        p.stroke(255, 255, 255, 35);
        p.strokeWeight(0.8);
        p.line(CB.x, CB.y, dotBX, dotBY);

        p.noStroke(); p.fill(255, 255, 255, 70);
        p.circle(CB.x, CB.y, 4);

        p.noStroke(); p.fill(255, 255, 255, 210);
        p.circle(dotBX, dotBY, 8);

        p.fill(255, 255, 255, 65);
        p.noStroke();
        p.textFont('Courier New');
        p.textSize(8);
        p.textAlign(p.CENTER);
        p.text('HEART  B', CB.x, CB.y + CB.r + 15);
        p.text(state.bpmB + ' BPM', CB.x, CB.y + CB.r + 26);
        p.noStroke();
        p.fill(255, 255, 255, state.fingerB ? 220 : 30);
        p.circle(CB.x, CB.y + CB.r + 38, 4);

        // ── Pen dot ───────────────────────────
        p.noStroke(); p.fill(255, 255, 255, 220);
        p.circle(penX, penY, 5);

        // ── Pen coordinates output (20Hz) ────
        if (p.frameCount % 3 === 0) {
          const normX = (penX - LX) / LR;
          const normY = (penY - LY) / LR;
          const xs = (normX >= 0 ? '+' : '') + normX.toFixed(3);
          const ys = (normY >= 0 ? '+' : '') + normY.toFixed(3);
          coordsEl.textContent = `x ${xs}   y ${ys}`;
          penWrite(`/pen/x ${normX.toFixed(4)}\n/pen/y ${normY.toFixed(4)}\n`);
        }
      };
    });
  </script>
</body>
</html>
